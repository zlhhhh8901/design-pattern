# design-pattern
### 工厂方法模式

在营销场景中经常会有某个用户做了一些操作；打卡、分享、留言、邀请注册等等，进行返利积分，最后通过积分在兑换商品，从而促活和拉新。

那么在这里我们模拟积分兑换中的发放多种类型商品，假如现在我们有如下三种类型的商品接口；

| 序号 | 类型               | 接口                                                         |
| ---- | ------------------ | ------------------------------------------------------------ |
| 1    | 优惠券             | `CouponResult sendCoupon(String uId, String couponNumber, String uuid)` |
| 2    | 实物商品           | `Boolean deliverGoods(DeliverReq req)`                       |
| 3    | 第三方爱奇艺兑换卡 | `void grantToken(String bindMobileNumber, String cardId)`    |

从以上接口来看有如下信息：

1. 三个接口返回类型不同，有对象类型、布尔类型、还有一个空类型。
2. 入参不同，发放优惠券需要仿重、兑换卡需要卡ID、实物商品需要发货位置(对象中含有)。
3. 另外可能会随着后续的业务的发展，会新增其他种商品类型。因为你所有的开发需求都是随着业务对市场的拓展而带来的



### 抽象工厂方法模式

项目初期只使用一个单机 `Redis`，但随着业务超过预期的快速发展，系统的负载能力也要随着跟上。这时候就需要更换为更为健壮的Redis集群服务，虽然需要修改但是不能影响目前系统的运行，还要平滑过渡过去。

随着这次的升级，可以预见的问题会有；

1. 很多服务用到了Redis需要一起升级到集群。
2. 需要兼容集群A和集群B，便于后续的灾备。
3. 两套集群提供的接口和方法各有差异，需要做适配。
4. 不能影响到目前正常运行的系统。



#### 重构

<img src="https://bugstack.cn/assets/images/2020/itstack-demo-design-2-08.png" style="zoom: 67%;" />

这里的抽象工厂的创建和获取方式，会采用代理类的方式进行实现。所被代理的类就是目前的Redis操作方法类，让这个类在不需要任何修改下，就可以实现调用集群A和集群B的数据服务。

并且这里还有一点非常重要，由于集群A和集群B在部分方法提供上是不同的，因此需要做一个接口适配，而这个适配类就相当于工厂中的工厂，用于创建把不同的服务抽象为统一的接口做相同的业务（跟上节工厂方法模型类型类似）。

工程中涉及的部分核心功能代码，如下：

- `ICacheAdapter`，定义了适配接口，分别包装两个集群中差异化的接口名称。`EGMCacheAdapter`、`IIRCacheAdapter`
- `JDKProxy`、`JDKInvocationHandler`，是代理类的定义和实现，这部分也就是抽象工厂的另外一种实现方式。通过这样的方式可以很好的把原有操作Redis的方法进行代理操作，通过控制不同的入参对象，控制缓存的使用。
